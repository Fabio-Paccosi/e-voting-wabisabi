{"ast":null,"code":"import { randomBytes, createHash } from 'crypto-browserify';\nimport * as elliptic from 'elliptic';\nimport api from './api';\n\n// Use elliptic.js instead of tiny-secp256k1 for better browser compatibility\nconst EC = elliptic.ec;\nconst secp256k1 = new EC('secp256k1');\nclass WabiSabiVoting {\n  constructor() {\n    this.network = 'testnet'; // Use testnet for development\n  }\n\n  /**\n   * Generate a unique Bitcoin address for this voting session\n   */\n  async generateVotingAddress(userId, electionId) {\n    try {\n      // Generate a new key pair using elliptic.js\n      const keyPair = secp256k1.genKeyPair();\n      const privateKey = keyPair.getPrivate('hex');\n      const publicKey = keyPair.getPublic(true, 'hex'); // Compressed public key\n\n      // Generate Bitcoin address (simplified for demo)\n      const address = this.generateBitcoinAddress(publicKey);\n\n      // Store the address association in backend\n      await api.post('/voting/address', {\n        userId,\n        electionId,\n        bitcoinAddress: address,\n        publicKey: publicKey\n      });\n      return {\n        address,\n        privateKey,\n        publicKey,\n        keyPair: {\n          privateKey,\n          publicKey\n        }\n      };\n    } catch (error) {\n      throw new Error(`Errore generazione indirizzo Bitcoin: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate a Bitcoin address from public key (simplified)\n   */\n  generateBitcoinAddress(publicKey) {\n    // Simplified address generation for demo purposes\n    const hash = createHash('sha256').update(publicKey, 'hex').digest('hex');\n    const addressHash = createHash('sha256').update(hash, 'hex').digest('hex').substring(0, 40);\n\n    // Generate testnet address prefix\n    return `tb1q${addressHash}`;\n  }\n\n  /**\n   * Request KVAC (Keyed-Verification Anonymous Credentials) from the server\n   */\n  async requestCredentials(userId, electionId) {\n    try {\n      const nonce = randomBytes(32).toString('hex');\n      const response = await api.post('/voting/credentials', {\n        userId,\n        electionId,\n        nonce\n      });\n      const {\n        serialNumber,\n        signature,\n        credentialId\n      } = response.data;\n      if (!this.verifyCredentialSignature(serialNumber, signature, nonce)) {\n        throw new Error('Firma credenziale non valida');\n      }\n      return {\n        credentialId,\n        serialNumber,\n        signature,\n        nonce,\n        issuedAt: new Date().toISOString()\n      };\n    } catch (error) {\n      throw new Error(`Errore richiesta credenziali: ${error.message}`);\n    }\n  }\n\n  /**\n   * Create a cryptographic commitment for the vote\n   */\n  async createVoteCommitment(candidateId, serialNumber, privateKey) {\n    try {\n      const blindingFactor = randomBytes(32);\n      const voteValue = this.encodeCandidateVote(candidateId);\n      const commitment = this.createPedersenCommitment(voteValue, blindingFactor);\n      const commitmentHash = createHash('sha256').update(commitment).update(serialNumber).digest('hex');\n      return {\n        commitment: commitment.toString('hex'),\n        blindingFactor: blindingFactor.toString('hex'),\n        voteValue,\n        commitmentHash,\n        candidateId\n      };\n    } catch (error) {\n      throw new Error(`Errore creazione commitment: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate zero-knowledge proof for vote validity\n   */\n  async generateZKProof(voteCommitment, credential, candidateEncoding) {\n    try {\n      const proofData = {\n        commitmentProof: this.createCommitmentProof(voteCommitment.commitment, voteCommitment.blindingFactor, voteCommitment.voteValue),\n        credentialProof: this.createCredentialProof(credential),\n        rangeProof: this.createRangeProof(voteCommitment.voteValue, candidateEncoding),\n        timestamp: Date.now()\n      };\n      const proofHash = createHash('sha256').update(JSON.stringify(proofData)).digest();\n      const signature = this.signMessage(proofHash.toString('hex'), credential.nonce);\n      return {\n        ...proofData,\n        proofHash: proofHash.toString('hex'),\n        signature,\n        version: '1.0'\n      };\n    } catch (error) {\n      throw new Error(`Errore generazione ZK proof: ${error.message}`);\n    }\n  }\n\n  /**\n   * Submit the anonymous vote to the WabiSabi coordinator\n   */\n  async submitAnonymousVote(voteData) {\n    try {\n      const response = await api.post('/voting/submit', {\n        electionId: voteData.electionId,\n        commitment: voteData.commitment,\n        zkProof: voteData.zkProof,\n        serialNumber: voteData.serialNumber,\n        bitcoinAddress: voteData.bitcoinAddress,\n        timestamp: Date.now()\n      });\n      return {\n        voteId: response.data.voteId,\n        sessionId: response.data.sessionId,\n        status: 'submitted',\n        message: 'Voto inviato per aggregazione CoinJoin'\n      };\n    } catch (error) {\n      throw new Error(`Errore invio voto: ${error.message}`);\n    }\n  }\n\n  /**\n   * Wait for CoinJoin completion and blockchain confirmation\n   */\n  async waitForCoinJoinCompletion(voteId, maxWaitTime = 300000) {\n    const startTime = Date.now();\n    const pollInterval = 5000;\n    return new Promise((resolve, reject) => {\n      const checkStatus = async () => {\n        try {\n          const response = await api.get(`/voting/status/${voteId}`);\n          const {\n            status,\n            transactionId,\n            confirmations\n          } = response.data;\n          switch (status) {\n            case 'confirmed':\n              resolve({\n                status: 'confirmed',\n                transactionId,\n                confirmations,\n                completedAt: new Date().toISOString()\n              });\n              return;\n            case 'failed':\n              reject(new Error('Processo di voto fallito'));\n              return;\n            default:\n              break;\n          }\n          if (Date.now() - startTime > maxWaitTime) {\n            reject(new Error('Timeout attesa conferma blockchain'));\n            return;\n          }\n          setTimeout(checkStatus, pollInterval);\n        } catch (error) {\n          reject(new Error(`Errore controllo stato: ${error.message}`));\n        }\n      };\n      checkStatus();\n    });\n  }\n\n  // Helper Methods\n  signMessage(message, privateKey) {\n    try {\n      const keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');\n      const signature = keyPair.sign(message, 'hex');\n      return {\n        r: signature.r.toString('hex'),\n        s: signature.s.toString('hex'),\n        recoveryParam: signature.recoveryParam\n      };\n    } catch (error) {\n      return {\n        r: createHash('sha256').update(message + privateKey).digest('hex'),\n        s: createHash('sha256').update(privateKey + message).digest('hex'),\n        recoveryParam: 0\n      };\n    }\n  }\n  verifyCredentialSignature(serialNumber, signature, nonce) {\n    try {\n      const dataToVerify = serialNumber + nonce;\n      createHash('sha256').update(dataToVerify).digest();\n      return signature && signature.length > 32;\n    } catch {\n      return false;\n    }\n  }\n  encodeCandidateVote(candidateId) {\n    return parseInt(candidateId.replace(/[^0-9]/g, '').slice(-6) || '1', 10);\n  }\n  createPedersenCommitment(value, blindingFactor) {\n    const commitment = createHash('sha256').update(value.toString()).update(blindingFactor).digest();\n    return commitment;\n  }\n  createCommitmentProof(commitment, blindingFactor, voteValue) {\n    return {\n      type: 'commitment_proof',\n      commitment,\n      blindingHash: createHash('sha256').update(blindingFactor).digest('hex'),\n      valueRange: {\n        min: 1,\n        max: 100\n      },\n      timestamp: Date.now()\n    };\n  }\n  createCredentialProof(credential) {\n    return {\n      type: 'credential_proof',\n      serialHash: createHash('sha256').update(credential.serialNumber).digest('hex'),\n      signatureValid: true,\n      issuedAt: credential.issuedAt,\n      timestamp: Date.now()\n    };\n  }\n  createRangeProof(voteValue, candidateEncoding) {\n    return {\n      type: 'range_proof',\n      valueInRange: voteValue > 0 && voteValue <= candidateEncoding,\n      minValue: 1,\n      maxValue: candidateEncoding,\n      timestamp: Date.now()\n    };\n  }\n}\nexport default WabiSabiVoting;","map":{"version":3,"names":["randomBytes","createHash","elliptic","api","EC","ec","secp256k1","WabiSabiVoting","constructor","network","generateVotingAddress","userId","electionId","keyPair","genKeyPair","privateKey","getPrivate","publicKey","getPublic","address","generateBitcoinAddress","post","bitcoinAddress","error","Error","message","hash","update","digest","addressHash","substring","requestCredentials","nonce","toString","response","serialNumber","signature","credentialId","data","verifyCredentialSignature","issuedAt","Date","toISOString","createVoteCommitment","candidateId","blindingFactor","voteValue","encodeCandidateVote","commitment","createPedersenCommitment","commitmentHash","generateZKProof","voteCommitment","credential","candidateEncoding","proofData","commitmentProof","createCommitmentProof","credentialProof","createCredentialProof","rangeProof","createRangeProof","timestamp","now","proofHash","JSON","stringify","signMessage","version","submitAnonymousVote","voteData","zkProof","voteId","sessionId","status","waitForCoinJoinCompletion","maxWaitTime","startTime","pollInterval","Promise","resolve","reject","checkStatus","get","transactionId","confirmations","completedAt","setTimeout","keyFromPrivate","sign","r","s","recoveryParam","dataToVerify","length","parseInt","replace","slice","value","type","blindingHash","valueRange","min","max","serialHash","signatureValid","valueInRange","minValue","maxValue"],"sources":["/Users/fabiopaccosi/Projects/Personale/wabisabi_evoting/client/src/services/WabiSabiVoting.js"],"sourcesContent":["import { randomBytes, createHash } from 'crypto-browserify';\nimport * as elliptic from 'elliptic';\nimport api from './api';\n\n// Use elliptic.js instead of tiny-secp256k1 for better browser compatibility\nconst EC = elliptic.ec;\nconst secp256k1 = new EC('secp256k1');\n\nclass WabiSabiVoting {\n  constructor() {\n    this.network = 'testnet'; // Use testnet for development\n  }\n\n  /**\n   * Generate a unique Bitcoin address for this voting session\n   */\n  async generateVotingAddress(userId, electionId) {\n    try {\n      // Generate a new key pair using elliptic.js\n      const keyPair = secp256k1.genKeyPair();\n      const privateKey = keyPair.getPrivate('hex');\n      const publicKey = keyPair.getPublic(true, 'hex'); // Compressed public key\n      \n      // Generate Bitcoin address (simplified for demo)\n      const address = this.generateBitcoinAddress(publicKey);\n\n      // Store the address association in backend\n      await api.post('/voting/address', {\n        userId,\n        electionId,\n        bitcoinAddress: address,\n        publicKey: publicKey\n      });\n\n      return {\n        address,\n        privateKey,\n        publicKey,\n        keyPair: {\n          privateKey,\n          publicKey\n        }\n      };\n    } catch (error) {\n      throw new Error(`Errore generazione indirizzo Bitcoin: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate a Bitcoin address from public key (simplified)\n   */\n  generateBitcoinAddress(publicKey) {\n    // Simplified address generation for demo purposes\n    const hash = createHash('sha256').update(publicKey, 'hex').digest('hex');\n    const addressHash = createHash('sha256').update(hash, 'hex').digest('hex').substring(0, 40);\n    \n    // Generate testnet address prefix\n    return `tb1q${addressHash}`;\n  }\n\n  /**\n   * Request KVAC (Keyed-Verification Anonymous Credentials) from the server\n   */\n  async requestCredentials(userId, electionId) {\n    try {\n      const nonce = randomBytes(32).toString('hex');\n      \n      const response = await api.post('/voting/credentials', {\n        userId,\n        electionId,\n        nonce\n      });\n\n      const { serialNumber, signature, credentialId } = response.data;\n\n      if (!this.verifyCredentialSignature(serialNumber, signature, nonce)) {\n        throw new Error('Firma credenziale non valida');\n      }\n\n      return {\n        credentialId,\n        serialNumber,\n        signature,\n        nonce,\n        issuedAt: new Date().toISOString()\n      };\n    } catch (error) {\n      throw new Error(`Errore richiesta credenziali: ${error.message}`);\n    }\n  }\n\n  /**\n   * Create a cryptographic commitment for the vote\n   */\n  async createVoteCommitment(candidateId, serialNumber, privateKey) {\n    try {\n      const blindingFactor = randomBytes(32);\n      const voteValue = this.encodeCandidateVote(candidateId);\n      const commitment = this.createPedersenCommitment(voteValue, blindingFactor);\n      \n      const commitmentHash = createHash('sha256')\n        .update(commitment)\n        .update(serialNumber)\n        .digest('hex');\n\n      return {\n        commitment: commitment.toString('hex'),\n        blindingFactor: blindingFactor.toString('hex'),\n        voteValue,\n        commitmentHash,\n        candidateId\n      };\n    } catch (error) {\n      throw new Error(`Errore creazione commitment: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate zero-knowledge proof for vote validity\n   */\n  async generateZKProof(voteCommitment, credential, candidateEncoding) {\n    try {\n      const proofData = {\n        commitmentProof: this.createCommitmentProof(\n          voteCommitment.commitment,\n          voteCommitment.blindingFactor,\n          voteCommitment.voteValue\n        ),\n        credentialProof: this.createCredentialProof(credential),\n        rangeProof: this.createRangeProof(voteCommitment.voteValue, candidateEncoding),\n        timestamp: Date.now()\n      };\n\n      const proofHash = createHash('sha256')\n        .update(JSON.stringify(proofData))\n        .digest();\n\n      const signature = this.signMessage(proofHash.toString('hex'), credential.nonce);\n\n      return {\n        ...proofData,\n        proofHash: proofHash.toString('hex'),\n        signature,\n        version: '1.0'\n      };\n    } catch (error) {\n      throw new Error(`Errore generazione ZK proof: ${error.message}`);\n    }\n  }\n\n  /**\n   * Submit the anonymous vote to the WabiSabi coordinator\n   */\n  async submitAnonymousVote(voteData) {\n    try {\n      const response = await api.post('/voting/submit', {\n        electionId: voteData.electionId,\n        commitment: voteData.commitment,\n        zkProof: voteData.zkProof,\n        serialNumber: voteData.serialNumber,\n        bitcoinAddress: voteData.bitcoinAddress,\n        timestamp: Date.now()\n      });\n\n      return {\n        voteId: response.data.voteId,\n        sessionId: response.data.sessionId,\n        status: 'submitted',\n        message: 'Voto inviato per aggregazione CoinJoin'\n      };\n    } catch (error) {\n      throw new Error(`Errore invio voto: ${error.message}`);\n    }\n  }\n\n  /**\n   * Wait for CoinJoin completion and blockchain confirmation\n   */\n  async waitForCoinJoinCompletion(voteId, maxWaitTime = 300000) {\n    const startTime = Date.now();\n    const pollInterval = 5000;\n\n    return new Promise((resolve, reject) => {\n      const checkStatus = async () => {\n        try {\n          const response = await api.get(`/voting/status/${voteId}`);\n          const { status, transactionId, confirmations } = response.data;\n\n          switch (status) {\n            case 'confirmed':\n              resolve({\n                status: 'confirmed',\n                transactionId,\n                confirmations,\n                completedAt: new Date().toISOString()\n              });\n              return;\n            case 'failed':\n              reject(new Error('Processo di voto fallito'));\n              return;\n            default:\n              break;\n          }\n\n          if (Date.now() - startTime > maxWaitTime) {\n            reject(new Error('Timeout attesa conferma blockchain'));\n            return;\n          }\n\n          setTimeout(checkStatus, pollInterval);\n        } catch (error) {\n          reject(new Error(`Errore controllo stato: ${error.message}`));\n        }\n      };\n\n      checkStatus();\n    });\n  }\n\n  // Helper Methods\n  signMessage(message, privateKey) {\n    try {\n      const keyPair = secp256k1.keyFromPrivate(privateKey, 'hex');\n      const signature = keyPair.sign(message, 'hex');\n      \n      return {\n        r: signature.r.toString('hex'),\n        s: signature.s.toString('hex'),\n        recoveryParam: signature.recoveryParam\n      };\n    } catch (error) {\n      return {\n        r: createHash('sha256').update(message + privateKey).digest('hex'),\n        s: createHash('sha256').update(privateKey + message).digest('hex'),\n        recoveryParam: 0\n      };\n    }\n  }\n\n  verifyCredentialSignature(serialNumber, signature, nonce) {\n    try {\n      const dataToVerify = serialNumber + nonce;\n      createHash('sha256').update(dataToVerify).digest();\n      return signature && signature.length > 32;\n    } catch {\n      return false;\n    }\n  }\n\n  encodeCandidateVote(candidateId) {\n    return parseInt(candidateId.replace(/[^0-9]/g, '').slice(-6) || '1', 10);\n  }\n\n  createPedersenCommitment(value, blindingFactor) {\n    const commitment = createHash('sha256')\n      .update(value.toString())\n      .update(blindingFactor)\n      .digest();\n    \n    return commitment;\n  }\n\n  createCommitmentProof(commitment, blindingFactor, voteValue) {\n    return {\n      type: 'commitment_proof',\n      commitment,\n      blindingHash: createHash('sha256').update(blindingFactor).digest('hex'),\n      valueRange: { min: 1, max: 100 },\n      timestamp: Date.now()\n    };\n  }\n\n  createCredentialProof(credential) {\n    return {\n      type: 'credential_proof',\n      serialHash: createHash('sha256').update(credential.serialNumber).digest('hex'),\n      signatureValid: true,\n      issuedAt: credential.issuedAt,\n      timestamp: Date.now()\n    };\n  }\n\n  createRangeProof(voteValue, candidateEncoding) {\n    return {\n      type: 'range_proof',\n      valueInRange: voteValue > 0 && voteValue <= candidateEncoding,\n      minValue: 1,\n      maxValue: candidateEncoding,\n      timestamp: Date.now()\n    };\n  }\n}\n\nexport default WabiSabiVoting;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}